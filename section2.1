import sympy as sp

# Define symbolic variables
theta1, theta2, theta3, theta4, theta5, theta6 = sp.symbols('theta1 theta2 theta3 theta4 theta5 theta6')
pi = sp.pi

# Define a function to create DH transformation matrix
def dh_matrix(a, alpha, d, theta):
    return sp.Matrix([
        [sp.cos(theta), -sp.sin(theta)*sp.cos(alpha), sp.sin(theta)*sp.sin(alpha), a*sp.cos(theta)],
        [sp.sin(theta), sp.cos(theta)*sp.cos(alpha), -sp.cos(theta)*sp.sin(alpha), a*sp.sin(theta)],
        [0, sp.sin(alpha), sp.cos(alpha), d],
        [0, 0, 0, 1]
    ])

# Define each transformation using DH parameters
T1 = dh_matrix(0.15, -pi/2, 0.286, theta1)
T2 = dh_matrix(0.475, 0, 0, theta2 - pi/2)
T3 = dh_matrix(0.5, 0, 0, theta3 + pi/2)
T4a = dh_matrix(0, pi/2, 0, pi/2)
T4 = dh_matrix(0, -pi/2, 0.1, theta4)
T5 = dh_matrix(0.165, 0, 0, theta5 - pi/2)
T6a = dh_matrix(0, pi/2, 0, pi/2)
T6 = dh_matrix(0, 0, 0.2, theta6)

# Compute the final FK transformation matrix
T_final = T1 * T2 * T3 * T4a * T4 * T5 * T6a * T6
T_final.simplify()
T_final.evalf(chop=True)  # Numeric evaluation (symbolic structure remains for clarity)

# Substitute joint values into the symbolic FK matrix
subs = {
    theta1: 0,
    theta2: -2.137,
    theta3: 1.8927,
    theta4: 0,
    theta5: -0.8461,
    theta6: 0
}

# Evaluate the final pose numerically
T_numeric = T_final.subs(subs).evalf()
T_numeric

# Show symbolic matrix
print("Symbolic Forward Kinematics Matrix (T_final):")
sp.pprint(T_final, use_unicode=True)

# Show numeric matrix after substituting joint values
print("\nNumerical Forward Kinematics Matrix (T_numeric):")
sp.pprint(T_numeric, use_unicode=True)
